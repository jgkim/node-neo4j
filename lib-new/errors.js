// Generated by CoffeeScript 1.11.1
(function() {
  var $, assert, http,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  $ = require('underscore');

  assert = require('assert');

  http = require('http');

  this.Error = (function(superClass) {
    extend(Error, superClass);

    function Error(message1, neo4j) {
      this.message = message1 != null ? message1 : 'Unknown error';
      this.neo4j = neo4j != null ? neo4j : {};
      this.name = 'neo4j.' + this.constructor.name;
      global.Error.captureStackTrace(this, this.constructor);
    }

    Error._fromResponse = function(resp) {
      var ErrorClass, ErrorType, body, error, headers, logBody, message, ref, reqText, statusCode, statusText;
      body = resp.body, headers = resp.headers, statusCode = resp.statusCode;
      if (statusCode < 400) {
        return null;
      }
      if (body != null ? (ref = body.errors) != null ? ref.length : void 0 : void 0) {
        error = body.errors[0];
        return this._fromObject(error);
      }
      ErrorType = statusCode >= 500 ? 'Database' : 'Client';
      ErrorClass = exports[ErrorType + "Error"];
      message = statusCode + " ";
      logBody = statusCode >= 500;
      if (body != null ? body.exception : void 0) {
        message += "[" + body.exception + "] " + (body.message || '(no message)');
      } else {
        statusText = http.STATUS_CODES[statusCode];
        reqText = resp.req.method + " " + resp.req.path;
        message += statusText + " response for " + reqText;
        logBody = true;
      }
      if (logBody && (body != null)) {
        message += ": " + (JSON.stringify(body, null, 4));
      }
      return new ErrorClass(message, body);
    };

    Error._fromObject = function(obj) {
      var ErrorClass, category, classification, code, fullMessage, message, neo, ref, stackTrace, title;
      if ((obj.stacktrace != null) && (obj.stackTrace == null)) {
        obj.stackTrace = obj.stacktrace;
        delete obj.stacktrace;
      }
      code = obj.code, message = obj.message, stackTrace = obj.stackTrace;
      ref = code.split('.'), neo = ref[0], classification = ref[1], category = ref[2], title = ref[3];
      ErrorClass = exports[classification];
      fullMessage = "[" + code + "] ";
      if (stackTrace && (classification === 'DatabaseError' || !message)) {
        if (message && (stackTrace.indexOf(message)) === -1) {
          stackTrace = message + ": " + stackTrace;
        }
        stackTrace = stackTrace.replace(/\t/g, '    ');
        if (stackTrace.slice(-1) !== '\n') {
          stackTrace += '\n';
        }
        stackTrace += '    <<< Neo4j stack above; Node.js stack below >>>';
        fullMessage += stackTrace;
      } else {
        fullMessage += message;
      }
      return new ErrorClass(fullMessage, obj);
    };

    return Error;

  })(global.Error);

  this.ClientError = (function(superClass) {
    extend(ClientError, superClass);

    function ClientError() {
      return ClientError.__super__.constructor.apply(this, arguments);
    }

    return ClientError;

  })(this.Error);

  this.DatabaseError = (function(superClass) {
    extend(DatabaseError, superClass);

    function DatabaseError() {
      return DatabaseError.__super__.constructor.apply(this, arguments);
    }

    return DatabaseError;

  })(this.Error);

  this.TransientError = (function(superClass) {
    extend(TransientError, superClass);

    function TransientError() {
      return TransientError.__super__.constructor.apply(this, arguments);
    }

    return TransientError;

  })(this.Error);

}).call(this);

//# sourceMappingURL=errors.js.map
